// Enhanced Inspection Service - Comprehensive Business Logic
// Orchestrates all inspection operations with workflow management, validation, and business rules
// Integrates with all supporting services for complete inspection lifecycle management

import { InspectionRepository, InspectionWithDetails } from '../repositories/InspectionRepository';
import { InspectionItemService } from './InspectionItemService';
import { WorkflowService, WorkflowTransitionRequest, WorkflowState, UserRole } from './WorkflowService';
import { VoiceProcessingService } from './VoiceProcessingService';
import { PhotoService } from './PhotoService';
import { DatabaseService } from '../types/common';
import { InspectionCreateRequest, InspectionUpdateRequest, PaginationOptions, InspectionFilters } from '../types/dtos';

export interface ComprehensiveInspection extends InspectionWithDetails {
  items?: any[];
  photos?: any[];
  workflow_history?: any[];
  statistics?: any;
}

export interface InspectionBusinessRules {
  maxInspectionDuration: number; // minutes
  requireManagerApprovalForCritical: boolean;
  autoCalculateUrgency: boolean;
  allowConcurrentEditing: boolean;
  mandatoryCategories: string[];
}

export interface InspectionSummary {
  totalItems: number;
  itemsByCondition: Record<string, number>;
  criticalIssues: string[];
  estimatedCost: number;
  nextServiceDate?: Date;
  overallRating: 'excellent' | 'good' | 'fair' | 'poor';
  recommendations: string[];
}

export interface InspectionOperationResult {
  success: boolean;
  inspection?: ComprehensiveInspection;
  summary?: InspectionSummary;
  validationResults?: any;
  errors?: string[];
  warnings?: string[];
}

export class EnhancedInspectionService {
  private inspectionRepository: InspectionRepository;
  private itemService: InspectionItemService;
  private workflowService: WorkflowService;
  private voiceService: VoiceProcessingService;
  private photoService: PhotoService;
  private db: DatabaseService;
  
  private businessRules: InspectionBusinessRules = {
    maxInspectionDuration: 120, // 2 hours
    requireManagerApprovalForCritical: true,
    autoCalculateUrgency: true,
    allowConcurrentEditing: false,
    mandatoryCategories: ['Brakes', 'Tires', 'Lights']
  };
  
  constructor(db: DatabaseService) {
    this.db = db;
    this.inspectionRepository = new InspectionRepository(db);
    this.itemService = new InspectionItemService(db);
    this.workflowService = new WorkflowService(db);
    this.voiceService = new VoiceProcessingService(db);
    this.photoService = new PhotoService(db);
  }
  
  // Create comprehensive inspection with initialization
  async createInspection(
    data: InspectionCreateRequest,
    userId: string,
    shopId: string
  ): Promise<InspectionOperationResult> {
    
    const client = await this.db.connect();
    
    try {
      await client.query('BEGIN');
      
      // Validate business rules
      const validation = await this.validateInspectionCreation(data, shopId);
      if (!validation.valid) {
        return { success: false, errors: validation.errors };
      }
      
      // Create inspection
      const inspection = await this.inspectionRepository.create(data, userId, shopId);
      
      // Initialize with default categories if requested
      if (data.initializeWithDefaults) {\n        await this.initializeDefaultCategories(inspection.id, shopId);\n      }\n      \n      // Generate inspection summary\n      const summary = await this.generateInspectionSummary(inspection.id, shopId);\n      \n      await client.query('COMMIT');\n      \n      return {\n        success: true,\n        inspection,\n        summary\n      };\n      \n    } catch (error) {\n      await client.query('ROLLBACK');\n      console.error('Create inspection error:', error);\n      return { success: false, errors: ['Failed to create inspection'] };\n    } finally {\n      client.release();\n    }\n  }\n  \n  // Get comprehensive inspection with all related data\n  async getInspectionById(\n    id: string,\n    shopId: string,\n    includeHistory: boolean = false\n  ): Promise<ComprehensiveInspection | null> {\n    \n    try {\n      // Get base inspection\n      const inspection = await this.inspectionRepository.findById(id, shopId);\n      if (!inspection) {\n        return null;\n      }\n      \n      // Enhance with related data\n      const comprehensive: ComprehensiveInspection = { ...inspection };\n      \n      // Add inspection items\n      comprehensive.items = await this.itemService.getInspectionItems(id, shopId, true);\n      \n      // Add photos\n      comprehensive.photos = await this.photoService.getInspectionPhotos(id, shopId);\n      \n      // Add workflow history if requested\n      if (includeHistory) {\n        comprehensive.workflow_history = await this.workflowService.getWorkflowHistory(id, shopId);\n      }\n      \n      // Add statistics\n      comprehensive.statistics = await this.itemService.getItemStatistics(id, shopId);\n      \n      return comprehensive;\n      \n    } catch (error) {\n      console.error('Get inspection error:', error);\n      return null;\n    }\n  }\n  \n  // Update inspection with business logic validation\n  async updateInspection(\n    id: string,\n    data: InspectionUpdateRequest,\n    userId: string,\n    shopId: string,\n    expectedVersion?: number\n  ): Promise<InspectionOperationResult> {\n    \n    try {\n      // Validate business rules for updates\n      const validation = await this.validateInspectionUpdate(id, data, shopId);\n      if (!validation.valid) {\n        return { success: false, errors: validation.errors, warnings: validation.warnings };\n      }\n      \n      // Check if inspection duration exceeds limit\n      const durationWarning = await this.checkInspectionDuration(id, shopId);\n      \n      // Update inspection\n      const inspection = await this.inspectionRepository.update(\n        id, data, userId, shopId, expectedVersion\n      );\n      \n      if (!inspection) {\n        return { success: false, errors: ['Inspection not found or version conflict'] };\n      }\n      \n      // Auto-calculate urgency if enabled\n      if (this.businessRules.autoCalculateUrgency && data.workflowState !== 'draft') {\n        await this.recalculateUrgency(id, shopId);\n      }\n      \n      // Generate updated summary\n      const summary = await this.generateInspectionSummary(id, shopId);\n      \n      const warnings = durationWarning ? [durationWarning] : [];\n      \n      return {\n        success: true,\n        inspection,\n        summary,\n        warnings\n      };\n      \n    } catch (error) {\n      console.error('Update inspection error:', error);\n      return { success: false, errors: ['Failed to update inspection'] };\n    }\n  }\n  \n  // Transition inspection state with validation\n  async transitionInspectionState(\n    id: string,\n    toState: WorkflowState,\n    userId: string,\n    userRole: UserRole,\n    shopId: string,\n    reason?: string\n  ): Promise<InspectionOperationResult> {\n    \n    try {\n      // Get current state\n      const currentState = await this.workflowService.getCurrentState(id, shopId);\n      if (!currentState) {\n        return { success: false, errors: ['Inspection not found'] };\n      }\n      \n      // Prepare transition request\n      const transitionRequest: WorkflowTransitionRequest = {\n        inspectionId: id,\n        fromState: currentState,\n        toState,\n        userId,\n        userRole,\n        shopId,\n        reason\n      };\n      \n      // Execute transition\n      const transitionResult = await this.workflowService.executeTransition(transitionRequest);\n      \n      if (!transitionResult.success) {\n        return { success: false, errors: transitionResult.errors };\n      }\n      \n      // Get updated inspection\n      const inspection = await this.getInspectionById(id, shopId);\n      \n      return {\n        success: true,\n        inspection\n      };\n      \n    } catch (error) {\n      console.error('State transition error:', error);\n      return { success: false, errors: ['Failed to transition inspection state'] };\n    }\n  }\n  \n  // Complete inspection with validation\n  async completeInspection(\n    id: string,\n    userId: string,\n    userRole: UserRole,\n    shopId: string\n  ): Promise<InspectionOperationResult> {\n    \n    try {\n      // Validate completion requirements\n      const validation = await this.validateInspectionCompletion(id, shopId);\n      if (!validation.valid) {\n        return { success: false, errors: validation.errors };\n      }\n      \n      // Transition to pending review or completed based on business rules\n      const targetState: WorkflowState = validation.requiresManagerReview \n        ? 'pending_review' \n        : 'approved';\n      \n      return await this.transitionInspectionState(\n        id, targetState, userId, userRole, shopId, \n        'Inspection completed by technician'\n      );\n      \n    } catch (error) {\n      console.error('Complete inspection error:', error);\n      return { success: false, errors: ['Failed to complete inspection'] };\n    }\n  }\n  \n  // Approve inspection (manager only)\n  async approveInspection(\n    id: string,\n    userId: string,\n    shopId: string\n  ): Promise<InspectionOperationResult> {\n    \n    return await this.transitionInspectionState(\n      id, 'approved', userId, 'shop_manager', shopId,\n      'Approved by manager'\n    );\n  }\n  \n  // Reject inspection (manager only)\n  async rejectInspection(\n    id: string,\n    reason: string,\n    userId: string,\n    shopId: string\n  ): Promise<InspectionOperationResult> {\n    \n    if (!reason || reason.trim().length === 0) {\n      return { success: false, errors: ['Rejection reason is required'] };\n    }\n    \n    return await this.transitionInspectionState(\n      id, 'rejected', userId, 'shop_manager', shopId, reason\n    );\n  }\n  \n  // Send inspection to customer\n  async sendToCustomer(\n    id: string,\n    userId: string,\n    shopId: string\n  ): Promise<InspectionOperationResult> {\n    \n    try {\n      // Validate customer contact info\n      const inspection = await this.inspectionRepository.findById(id, shopId);\n      if (!inspection) {\n        return { success: false, errors: ['Inspection not found'] };\n      }\n      \n      // Transition state\n      const result = await this.transitionInspectionState(\n        id, 'sent_to_customer', userId, 'shop_manager', shopId,\n        'Sent to customer'\n      );\n      \n      if (result.success) {\n        // TODO: Integrate with SMS service to actually send the message\n        console.log(`SMS would be sent for inspection ${id}`);\n      }\n      \n      return result;\n      \n    } catch (error) {\n      console.error('Send to customer error:', error);\n      return { success: false, errors: ['Failed to send inspection to customer'] };\n    }\n  }\n  \n  // Get inspections with filtering and pagination\n  async getInspections(\n    shopId: string,\n    filters: InspectionFilters = {},\n    pagination: PaginationOptions = {}\n  ): Promise<{ inspections: InspectionWithDetails[]; total: number }> {\n    \n    return await this.inspectionRepository.findByShop(shopId, filters, pagination);\n  }\n  \n  // Get inspections requiring attention\n  async getInspectionsRequiringAttention(\n    shopId: string\n  ): Promise<InspectionWithDetails[]> {\n    \n    return await this.inspectionRepository.getRequiringAttention(shopId);\n  }\n  \n  // Get inspection statistics\n  async getInspectionStatistics(\n    shopId: string,\n    dateFrom?: Date,\n    dateTo?: Date\n  ): Promise<any> {\n    \n    const stats = await this.inspectionRepository.getStatistics(shopId, dateFrom, dateTo);\n    const workflowStats = await this.workflowService.getWorkflowStatistics(shopId);\n    \n    return {\n      ...stats,\n      workflow: workflowStats\n    };\n  }\n  \n  // Delete inspection (soft delete)\n  async deleteInspection(\n    id: string,\n    userId: string,\n    shopId: string\n  ): Promise<boolean> {\n    \n    try {\n      // Check if inspection can be deleted (business rules)\n      const inspection = await this.inspectionRepository.findById(id, shopId);\n      if (!inspection) {\n        return false;\n      }\n      \n      // Only allow deletion of draft inspections\n      if (inspection.workflow_state !== 'draft') {\n        throw new Error('Only draft inspections can be deleted');\n      }\n      \n      return await this.inspectionRepository.delete(id, userId, shopId);\n      \n    } catch (error) {\n      console.error('Delete inspection error:', error);\n      return false;\n    }\n  }\n  \n  // Generate inspection summary\n  async generateInspectionSummary(\n    inspectionId: string,\n    shopId: string\n  ): Promise<InspectionSummary> {\n    \n    try {\n      const items = await this.itemService.getInspectionItems(inspectionId, shopId, true);\n      const statistics = await this.itemService.getItemStatistics(inspectionId, shopId);\n      \n      // Calculate overall rating\n      let overallRating: 'excellent' | 'good' | 'fair' | 'poor' = 'excellent';\n      \n      if (statistics.critical_items > 0) {\n        overallRating = 'poor';\n      } else if (statistics.poor_items > 0) {\n        overallRating = 'fair';\n      } else if (statistics.fair_items > 0) {\n        overallRating = 'good';\n      }\n      \n      // Generate recommendations\n      const recommendations = this.generateRecommendations(items, overallRating);\n      \n      // Get critical issues\n      const criticalIssues = items\n        .filter(item => item.condition === 'needs_immediate')\n        .map(item => `${item.component}: ${item.notes || 'Immediate attention required'}`);\n      \n      return {\n        totalItems: statistics.total_items || 0,\n        itemsByCondition: {\n          good: statistics.good_items || 0,\n          fair: statistics.fair_items || 0,\n          poor: statistics.poor_items || 0,\n          needs_immediate: statistics.critical_items || 0\n        },\n        criticalIssues,\n        estimatedCost: parseFloat(statistics.total_estimated_cost || '0'),\n        overallRating,\n        recommendations\n      };\n      \n    } catch (error) {\n      console.error('Generate summary error:', error);\n      return {\n        totalItems: 0,\n        itemsByCondition: { good: 0, fair: 0, poor: 0, needs_immediate: 0 },\n        criticalIssues: [],\n        estimatedCost: 0,\n        overallRating: 'good',\n        recommendations: []\n      };\n    }\n  }\n  \n  // Private helper methods\n  \n  private async validateInspectionCreation(\n    data: InspectionCreateRequest,\n    shopId: string\n  ): Promise<{ valid: boolean; errors: string[] }> {\n    \n    const errors: string[] = [];\n    \n    // Validate vehicle exists and belongs to shop\n    const vehicleCheck = await this.db.query(`\n      SELECT v.id \n      FROM vehicles v \n      JOIN customers c ON v.customer_id = c.id \n      WHERE v.id = $1 AND c.shop_id = $2\n    `, [data.vehicleId, shopId]);\n    \n    if (vehicleCheck.rows.length === 0) {\n      errors.push('Vehicle not found or does not belong to this shop');\n    }\n    \n    // Check for concurrent inspections on same vehicle\n    const activeInspections = await this.db.query(`\n      SELECT COUNT(*) as count \n      FROM inspections \n      WHERE vehicle_id = $1 \n        AND shop_id = $2 \n        AND workflow_state IN ('draft', 'in_progress', 'pending_review')\n        AND deleted_at IS NULL\n    `, [data.vehicleId, shopId]);\n    \n    if (parseInt(activeInspections.rows[0].count) > 0) {\n      errors.push('Vehicle already has an active inspection');\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n  \n  private async validateInspectionUpdate(\n    id: string,\n    data: InspectionUpdateRequest,\n    shopId: string\n  ): Promise<{ valid: boolean; errors: string[]; warnings: string[] }> {\n    \n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    // Check concurrent editing if not allowed\n    if (!this.businessRules.allowConcurrentEditing && data.workflowState) {\n      const recentUpdates = await this.db.query(`\n        SELECT updated_at \n        FROM inspections \n        WHERE id = $1 AND shop_id = $2 \n          AND updated_at > NOW() - INTERVAL '5 minutes'\n      `, [id, shopId]);\n      \n      if (recentUpdates.rows.length > 0) {\n        warnings.push('Inspection was recently updated by another user');\n      }\n    }\n    \n    return { valid: errors.length === 0, errors, warnings };\n  }\n  \n  private async validateInspectionCompletion(\n    inspectionId: string,\n    shopId: string\n  ): Promise<{ valid: boolean; errors: string[]; requiresManagerReview: boolean }> {\n    \n    const errors: string[] = [];\n    let requiresManagerReview = false;\n    \n    // Check mandatory categories\n    const items = await this.itemService.getInspectionItems(inspectionId, shopId);\n    const categoriesPresent = new Set(items.map(item => item.category));\n    \n    for (const mandatoryCategory of this.businessRules.mandatoryCategories) {\n      if (!categoriesPresent.has(mandatoryCategory)) {\n        errors.push(`Missing mandatory category: ${mandatoryCategory}`);\n      }\n    }\n    \n    // Check for critical items\n    const criticalItems = items.filter(item => item.condition === 'needs_immediate');\n    if (criticalItems.length > 0 && this.businessRules.requireManagerApprovalForCritical) {\n      requiresManagerReview = true;\n    }\n    \n    // Ensure all items have conditions\n    const incompleteItems = items.filter(item => !item.condition || item.condition === '');\n    if (incompleteItems.length > 0) {\n      errors.push(`${incompleteItems.length} items missing condition assessment`);\n    }\n    \n    return { valid: errors.length === 0, errors, requiresManagerReview };\n  }\n  \n  private async checkInspectionDuration(\n    inspectionId: string,\n    shopId: string\n  ): Promise<string | null> {\n    \n    const inspection = await this.inspectionRepository.findById(inspectionId, shopId);\n    \n    if (inspection?.started_at) {\n      const duration = (Date.now() - inspection.started_at.getTime()) / (1000 * 60); // minutes\n      \n      if (duration > this.businessRules.maxInspectionDuration) {\n        return `Inspection duration (${Math.round(duration)} min) exceeds recommended maximum (${this.businessRules.maxInspectionDuration} min)`;\n      }\n    }\n    \n    return null;\n  }\n  \n  private async recalculateUrgency(\n    inspectionId: string,\n    shopId: string\n  ): Promise<void> {\n    \n    // This would use the database function to recalculate urgency\n    await this.db.query(\n      'UPDATE inspections SET urgency_level = calculate_inspection_urgency($1) WHERE id = $1 AND shop_id = $2',\n      [inspectionId, shopId]\n    );\n  }\n  \n  private async initializeDefaultCategories(\n    inspectionId: string,\n    shopId: string\n  ): Promise<void> {\n    \n    const categories = await this.itemService.getInspectionCategories(shopId);\n    const defaultItems: any[] = [];\n    \n    for (const category of categories) {\n      for (const component of category.default_components) {\n        defaultItems.push({\n          category: category.name,\n          component: component,\n          condition: 'good',\n          sortOrder: category.sort_order * 100 + defaultItems.length\n        });\n      }\n    }\n    \n    if (defaultItems.length > 0) {\n      await this.itemService.createBulkItems(inspectionId, defaultItems, shopId);\n    }\n  }\n  \n  private generateRecommendations(\n    items: any[],\n    overallRating: string\n  ): string[] {\n    \n    const recommendations: string[] = [];\n    \n    // Overall recommendations based on rating\n    switch (overallRating) {\n      case 'poor':\n        recommendations.push('Vehicle has critical safety issues that require immediate attention');\n        break;\n      case 'fair':\n        recommendations.push('Vehicle has items that should be addressed soon to maintain safety and reliability');\n        break;\n      case 'good':\n        recommendations.push('Vehicle is in good condition with minor items to monitor');\n        break;\n      case 'excellent':\n        recommendations.push('Vehicle is in excellent condition - continue regular maintenance schedule');\n        break;\n    }\n    \n    // Specific recommendations based on items\n    const criticalItems = items.filter(item => item.condition === 'needs_immediate');\n    if (criticalItems.length > 0) {\n      recommendations.push(`Address ${criticalItems.length} critical safety items before driving`);\n    }\n    \n    const poorItems = items.filter(item => item.condition === 'poor');\n    if (poorItems.length > 0) {\n      recommendations.push(`Schedule service for ${poorItems.length} items in poor condition`);\n    }\n    \n    const fairItems = items.filter(item => item.condition === 'fair');\n    if (fairItems.length > 3) {\n      recommendations.push('Multiple items showing wear - consider comprehensive service');\n    }\n    \n    return recommendations;\n  }\n}